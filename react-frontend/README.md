# Oedipus React Frontend - Application Guide

## Overview

The Oedipus React Frontend is a comprehensive comparative analysis platform built with React, TypeScript, and Tailwind CSS. It provides an intuitive interface for uploading datasets, creating comparisons, and analyzing AI model completions with detailed statistical insights.

## Architecture

### Routing System
The application uses a custom **SimpleRouter** with hash-based navigation for reliability and debugging capabilities. The router provides:
- Hash-based URLs (`#/route`) for stable navigation
- Built-in navigation bar for easy route switching
- Console logging for debugging route changes
- Fallback to main app for unknown routes

### Navigation Bar
Every page includes a navigation bar with quick access to all routes:
```
Main App | Diagnostic | Simple Test | Debug Hooks
```

## Routes & Pages

### üè† Main App (`/` or `#/`)
**Purpose**: The complete Oedipus Comparative Analysis application

**Design**:
- **Header**: Branded header with logo and app description
- **Three-step wizard**:
  1. **Upload Data**: Drag-and-drop interface for CSV files
  2. **Create Comparison**: Configure comparison parameters
  3. **View Results**: Interactive charts, statistics, and insights
- **Progress indicators** showing current step
- **Responsive layout** optimized for data analysis workflows

**Functionality**:
- Upload prompt datasets (CSV format with `prompt_id`, `prompt_text`)
- Upload completion datasets (CSV format with `prompt_id`, `completion_text`)
- Data validation and preview before processing
- Create comparative analyses between model completions
- Interactive visualizations using Recharts
- Statistical test results and significance analysis
- Auto-generated insights based on data patterns
- Export functionality for reports and charts

**Key Components**:
- `DragDropUploader`: File upload with validation
- `DatasetPreview`: Data preview and validation messages
- `AlignedDataTable`: Side-by-side comparison display
- `ComparisonCharts`: Statistical visualizations
- `StatisticalSummary`: Key metrics overview
- `TestResults`: Hypothesis testing results
- `AutoGeneratedInsights`: AI-powered insights
- `ReportGenerator`: Export and sharing tools

**State Management**:
- **React Query**: Server state management for API calls
- **Local State**: Form data, current step, selected comparisons
- **Zustand**: Complex shared state (if needed)

---

### üîç Diagnostic (`#/diagnostic`)
**Purpose**: System health checks and troubleshooting tool

**Design**:
- **Clean diagnostic interface** with status cards
- **Real-time connectivity testing** with visual indicators
- **Color-coded status**: Green (success), Red (failure), Blue (checking)
- **Detailed error reporting** with actionable solutions

**Functionality**:
- **React App Status**: Confirms React rendering, CSS, JavaScript execution
- **Backend Connection Test**: Tests API connectivity to `localhost:8000/health`
- **Environment Information**: Browser details and system info
- **Retry Mechanism**: Manual connection retesting
- **Solution Guidance**: Step-by-step troubleshooting instructions

**When to Use**:
- First-time setup verification
- Backend connectivity issues
- Deployment troubleshooting
- Environment validation
- Before reporting bugs

**Key Features**:
- Live backend status monitoring
- Connection details display
- Browser environment analysis
- Instant retry functionality
- Clear next-step instructions

---

### ‚ö° Simple Test (`#/simple`)
**Purpose**: Basic rendering and styling verification

**Design**:
- **Minimal layout** focusing on core functionality tests
- **Status cards** showing successful operations
- **Branded header** matching main app design
- **Clean typography** with clear success indicators

**Functionality**:
- **React Rendering Test**: Confirms component mounting
- **Tailwind CSS Test**: Verifies styling framework
- **Component Structure Test**: Validates layout rendering
- **JavaScript Execution Test**: Confirms script loading

**When to Use**:
- Isolating rendering issues
- CSS framework problems
- JavaScript loading errors
- Component structure debugging
- After dependency updates

**Status Indicators**:
- ‚úÖ App Rendering Successfully
- ‚úÖ React rendering: Working
- ‚úÖ Tailwind CSS: Working
- ‚úÖ Component structure: Working

---

### üêõ Debug Hooks (`#/debug`)
**Purpose**: React Query hook debugging and API state inspection

**Design**:
- **Developer-focused interface** with detailed state information
- **Real-time state monitoring** with automatic updates
- **Structured data display** using JSON formatting
- **Color-coded status indicators** for quick identification

**Functionality**:
- **useDatasets() Hook Analysis**: Real-time hook state inspection for prompt datasets
- **useAllCompletionDatasets() Hook Analysis**: Real-time hook state inspection for completion datasets
- **Loading State Monitoring**: Track async operation states
- **Error State Debugging**: Detailed error information display
- **Data Inspection**: Raw API response examination
- **Manual Testing Tools**: Direct API test and refetch buttons

**State Information Displayed**:
- **Loading**: Current async operation status
- **Error**: Detailed error messages and stack traces
- **Prompts Count**: Number of loaded prompt datasets
- **Completions Count**: Number of loaded completion datasets
- **Raw Data**: Complete API responses for both hooks
- **Hook Lifecycle**: State changes and transitions

**Interactive Tools**:
- **Refetch Completions**: Manual trigger to reload completion datasets
- **Test Direct API**: Bypass React Query to test raw API connectivity
- **Bug Fix Documentation**: Records of recent fixes and their solutions

**When to Use**:
- API integration debugging
- React Query state issues
- Data loading problems
- Hook performance analysis
- Backend integration testing
- Investigating caching issues

**Recent Fixes Documented**:
- **Automatic Completion Loading**: Fixed React Query caching issue that prevented completion datasets from loading automatically after upload

## Technical Stack

### Core Technologies
- **React 18.2.0**: UI framework with concurrent features
- **TypeScript**: Type-safe development
- **Vite**: Fast build tool and dev server
- **Tailwind CSS**: Utility-first styling framework

### Data & State Management
- **TanStack React Query 4.32.6**: Server state management
- **Zustand 4.4.1**: Client state management
- **React Hook Form**: Form handling with validation

### Visualization & UI
- **Recharts 2.8.0**: Chart and visualization library
- **Lucide React**: Modern icon library
- **React Dropzone**: File upload interface
- **Papa Parse**: CSV parsing and processing

### Development Tools
- **ESLint**: Code linting and quality
- **TypeScript Compiler**: Type checking
- **PostCSS**: CSS processing
- **Autoprefixer**: CSS vendor prefixes

## Development Workflow

### Local Development
```bash
npm run dev          # Start development server
npm run type-check   # TypeScript validation
npm run lint         # Code quality check
npm run build        # Production build
```

### Debugging Process
1. **Start with Diagnostic** (`#/diagnostic`) - Verify system health
2. **Test Basic Rendering** (`#/simple`) - Isolate rendering issues
3. **Debug API Hooks** (`#/debug`) - Inspect data loading
4. **Main App Testing** (`#/`) - Full application testing

### Route-Specific Debugging

**For Blank Pages**:
1. Check Diagnostic page for system status
2. Use Simple Test to verify basic rendering
3. Inspect browser console for JavaScript errors
4. Use Debug Hooks to check API connectivity

**For Data Issues**:
1. Use Debug Hooks to inspect API responses
2. Check backend connectivity in Diagnostic
3. Verify CSV format in main app preview
4. Review validation messages

**For Styling Issues**:
1. Simple Test shows Tailwind CSS status
2. Check browser dev tools for CSS loading
3. Verify Tailwind configuration
4. Review component class names

## API Integration

### Backend Requirements
The React app connects to the Oedipus FastAPI backend at `http://localhost:8000`.

**Required Endpoints**:
```
GET  /health                          # System status
GET  /api/v1/datasets/               # List datasets
POST /api/v1/datasets/               # Upload prompt dataset
POST /api/v1/datasets/{id}/completions   # Upload completion dataset
POST /api/v1/comparisons/create      # Create comparison
GET  /api/v1/comparisons/{id}        # Get comparison results
```

### Error Handling
- **Connection Errors**: Displayed with retry options
- **Validation Errors**: Shown inline with correction guidance
- **API Errors**: Detailed error messages with troubleshooting steps
- **Loading States**: Progress indicators for all async operations

## File Structure

```
src/
‚îú‚îÄ‚îÄ components/           # React components
‚îÇ   ‚îú‚îÄ‚îÄ DatasetUpload/    # File upload functionality
‚îÇ   ‚îú‚îÄ‚îÄ ComparisonTable/  # Data comparison display
‚îÇ   ‚îú‚îÄ‚îÄ MetricsComparison/# Charts and statistics
‚îÇ   ‚îú‚îÄ‚îÄ StatisticalTests/ # Test results display
‚îÇ   ‚îú‚îÄ‚îÄ InsightsPanel/    # Auto-generated insights
‚îÇ   ‚îî‚îÄ‚îÄ Export/           # Report generation
‚îú‚îÄ‚îÄ hooks/                # Custom React hooks
‚îÇ   ‚îî‚îÄ‚îÄ useComparison.ts  # API integration hooks
‚îú‚îÄ‚îÄ types/                # TypeScript definitions
‚îú‚îÄ‚îÄ utils/                # Helper functions
‚îú‚îÄ‚îÄ App.tsx               # Main application component
‚îú‚îÄ‚îÄ AppSimple.tsx         # Simple rendering test
‚îú‚îÄ‚îÄ AppDebug.tsx          # Hook debugging component
‚îú‚îÄ‚îÄ DiagnosticApp.tsx     # System diagnostic tool
‚îú‚îÄ‚îÄ SimpleRouter.tsx      # Hash-based routing system
‚îî‚îÄ‚îÄ main.tsx              # Application entry point
```

## Usage Examples

### Upload Workflow
1. Navigate to main app (`#/`)
2. Drag and drop input CSV file
3. Review data preview and validation
4. Upload corresponding output CSV files
5. Create comparison analysis
6. Explore results and insights

### Troubleshooting Workflow
1. Issue detected in main app
2. Check Diagnostic (`#/diagnostic`) for system status
3. Use Simple Test (`#/simple`) if rendering issues
4. Use Debug Hooks (`#/debug`) for API problems
5. Return to main app with identified solution

### Development Testing
1. Code changes made
2. Quick verification with Simple Test
3. API testing with Debug Hooks
4. Full workflow testing in main app
5. System validation with Diagnostic

## Support & Maintenance

### For Users
- Use Diagnostic page for connection issues
- Check browser console (F12) for errors
- Verify backend is running on localhost:8000
- Try different routes to isolate issues

### For Developers
- All routes include console logging
- Debug Hooks provide detailed state information
- Simple Test isolates rendering problems
- Error boundaries prevent app crashes

### Monitoring
- All API calls logged in browser console
- Hook state changes tracked in Debug route
- Connection status monitored in Diagnostic
- Performance metrics available in dev tools

This multi-route architecture ensures robust debugging capabilities while providing a smooth user experience for the main comparative analysis workflow.